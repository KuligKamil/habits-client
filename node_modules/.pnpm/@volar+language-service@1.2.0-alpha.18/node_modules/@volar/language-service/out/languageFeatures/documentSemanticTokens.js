Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const vscode = require("vscode-languageserver-protocol");
const featureWorkers_1 = require("../utils/featureWorkers");
function register(context) {
    return (uri, range, legend, cancelToken, reportProgress) => {
        const document = context.getTextDocument(uri);
        if (!document)
            return;
        const offsetRange = range ? [
            document.offsetAt(range.start),
            document.offsetAt(range.end),
        ] : [
            0,
            document.getText().length,
        ];
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, offsetRange, function* (offsetRange, map) {
            if (cancelToken === null || cancelToken === void 0 ? void 0 : cancelToken.isCancellationRequested)
                return;
            let range;
            for (const mapping of map.map.mappings) {
                if (mapping.data.semanticTokens
                    && mapping.sourceRange[1] > offsetRange[0]
                    && mapping.sourceRange[0] < offsetRange[1]) {
                    if (!range) {
                        range = [...mapping.generatedRange];
                    }
                    else {
                        range[0] = Math.min(range[0], mapping.generatedRange[0]);
                        range[1] = Math.max(range[1], mapping.generatedRange[1]);
                    }
                }
            }
            if (range) {
                yield range;
            }
        }, (plugin, document, offsetRange) => {
            var _a;
            return (_a = plugin.findDocumentSemanticTokens) === null || _a === void 0 ? void 0 : _a.call(plugin, document, vscode.Range.create(document.positionAt(offsetRange[0]), document.positionAt(offsetRange[1])), legend);
        }, (tokens, map) => tokens.map(_token => {
            if (!map)
                return _token;
            const range = map.toSourceRange({
                start: { line: _token[0], character: _token[1] },
                end: { line: _token[0], character: _token[1] + _token[2] },
            }, data => !!data.semanticTokens);
            if (range) {
                return [range.start.line, range.start.character, _token[2], _token[3], _token[4]];
            }
        }).filter(shared.notEmpty), tokens => tokens.flat(), reportProgress);
    };
}
exports.register = register;
//# sourceMappingURL=documentSemanticTokens.js.map