Object.defineProperty(exports, "__esModule", { value: true });
exports.createLanguageService = void 0;
const language_core_1 = require("@volar/language-core");
const shared = require("@volar/shared");
const tsFaster = require("@volar/typescript-faster");
const vscode_languageserver_textdocument_1 = require("vscode-languageserver-textdocument");
const documents_1 = require("./documents");
const autoInsert = require("./languageFeatures/autoInsert");
const callHierarchy = require("./languageFeatures/callHierarchy");
const codeActionResolve = require("./languageFeatures/codeActionResolve");
const codeActions = require("./languageFeatures/codeActions");
const codeLens = require("./languageFeatures/codeLens");
const codeLensResolve = require("./languageFeatures/codeLensResolve");
const completions = require("./languageFeatures/complete");
const completionResolve = require("./languageFeatures/completeResolve");
const definition = require("./languageFeatures/definition");
const documentHighlight = require("./languageFeatures/documentHighlights");
const documentLink = require("./languageFeatures/documentLinks");
const semanticTokens = require("./languageFeatures/documentSemanticTokens");
const fileReferences = require("./languageFeatures/fileReferences");
const fileRename = require("./languageFeatures/fileRename");
const hover = require("./languageFeatures/hover");
const inlayHints = require("./languageFeatures/inlayHints");
const references = require("./languageFeatures/references");
const rename = require("./languageFeatures/rename");
const renamePrepare = require("./languageFeatures/renamePrepare");
const signatureHelp = require("./languageFeatures/signatureHelp");
const diagnostics = require("./languageFeatures/validation");
const workspaceSymbol = require("./languageFeatures/workspaceSymbols");
const colorPresentations = require("./documentFeatures/colorPresentations");
const documentColors = require("./documentFeatures/documentColors");
const documentSymbols = require("./documentFeatures/documentSymbols");
const foldingRanges = require("./documentFeatures/foldingRanges");
const format = require("./documentFeatures/format");
const linkedEditingRanges = require("./documentFeatures/linkedEditingRanges");
const selectionRanges = require("./documentFeatures/selectionRanges");
function createLanguageService(host, config, env, documentRegistry) {
    var _a;
    const languageContext = (0, language_core_1.createLanguageContext)(host, Object.values((_a = config.languages) !== null && _a !== void 0 ? _a : {}).filter(shared.notEmpty));
    const context = createLanguageServiceContext(host, languageContext, config, env, documentRegistry);
    return createLanguageServiceBase(context);
}
exports.createLanguageService = createLanguageService;
function createLanguageServiceContext(host, languageContext, config, env, documentRegistry) {
    var _a;
    const ts = (_a = host.getTypeScriptModule) === null || _a === void 0 ? void 0 : _a.call(host);
    const tsLs = ts === null || ts === void 0 ? void 0 : ts.createLanguageService(languageContext.typescript.languageServiceHost, documentRegistry);
    if (ts && tsLs) {
        tsFaster.decorate(ts, languageContext.typescript.languageServiceHost, tsLs);
    }
    let plugins;
    const textDocumentMapper = (0, documents_1.createDocumentsAndSourceMaps)(languageContext.virtualFiles);
    const documents = new WeakMap();
    const documentVersions = new Map();
    const context = {
        uriToFileName: shared.uriToFileName,
        fileNameToUri: shared.fileNameToUri,
        host,
        core: languageContext,
        env: env,
        get plugins() {
            var _a, _b;
            if (!plugins) {
                plugins = {}; // avoid infinite loop
                for (const pluginId in (_a = config.plugins) !== null && _a !== void 0 ? _a : {}) {
                    const plugin = (_b = config.plugins) === null || _b === void 0 ? void 0 : _b[pluginId];
                    if (plugin instanceof Function) {
                        const _plugin = plugin(this);
                        plugins[pluginId] = _plugin;
                    }
                    else if (plugin) {
                        plugins[pluginId] = plugin;
                    }
                }
            }
            return plugins;
        },
        config,
        typescript: ts && tsLs ? {
            module: ts,
            languageServiceHost: languageContext.typescript.languageServiceHost,
            languageService: tsLs,
        } : undefined,
        documents: textDocumentMapper,
        getTextDocument,
    };
    return context;
    function getTextDocument(uri) {
        var _a;
        const fileName = shared.uriToFileName(uri);
        const scriptSnapshot = host.getScriptSnapshot(fileName);
        if (scriptSnapshot) {
            let document = documents.get(scriptSnapshot);
            if (!document) {
                const newVersion = ((_a = documentVersions.get(uri.toLowerCase())) !== null && _a !== void 0 ? _a : 0) + 1;
                documentVersions.set(uri.toLowerCase(), newVersion);
                document = vscode_languageserver_textdocument_1.TextDocument.create(uri, shared.syntaxToLanguageId(uri.substring(uri.lastIndexOf('.') + 1)), newVersion, scriptSnapshot.getText(0, scriptSnapshot.getLength()));
                documents.set(scriptSnapshot, document);
            }
            return document;
        }
    }
}
function createLanguageServiceBase(context) {
    return {
        triggerCharacters: Object.values(context.plugins).map(plugin => { var _a, _b; return (_b = (_a = plugin.complete) === null || _a === void 0 ? void 0 : _a.triggerCharacters) !== null && _b !== void 0 ? _b : []; }).flat(),
        format: format.register(context),
        getFoldingRanges: foldingRanges.register(context),
        getSelectionRanges: selectionRanges.register(context),
        findLinkedEditingRanges: linkedEditingRanges.register(context),
        findDocumentSymbols: documentSymbols.register(context),
        findDocumentColors: documentColors.register(context),
        getColorPresentations: colorPresentations.register(context),
        doValidation: diagnostics.register(context),
        findReferences: references.register(context),
        findFileReferences: fileReferences.register(context),
        findDefinition: definition.register(context, 'findDefinition', data => !!data.definition, data => !!data.definition),
        findTypeDefinition: definition.register(context, 'findTypeDefinition', data => !!data.definition, data => !!data.definition),
        findImplementations: definition.register(context, 'findImplementations', data => !!data.references, () => false),
        prepareRename: renamePrepare.register(context),
        doRename: rename.register(context),
        getEditsForFileRename: fileRename.register(context),
        getSemanticTokens: semanticTokens.register(context),
        doHover: hover.register(context),
        doComplete: completions.register(context),
        doCodeActions: codeActions.register(context),
        doCodeActionResolve: codeActionResolve.register(context),
        doCompletionResolve: completionResolve.register(context),
        getSignatureHelp: signatureHelp.register(context),
        doCodeLens: codeLens.register(context),
        doCodeLensResolve: codeLensResolve.register(context),
        findDocumentHighlights: documentHighlight.register(context),
        findDocumentLinks: documentLink.register(context),
        findWorkspaceSymbols: workspaceSymbol.register(context),
        doAutoInsert: autoInsert.register(context),
        getInlayHints: inlayHints.register(context),
        callHierarchy: callHierarchy.register(context),
        dispose: () => { var _a; return (_a = context.typescript) === null || _a === void 0 ? void 0 : _a.languageService.dispose(); },
        context,
    };
}
//# sourceMappingURL=baseLanguageService.js.map