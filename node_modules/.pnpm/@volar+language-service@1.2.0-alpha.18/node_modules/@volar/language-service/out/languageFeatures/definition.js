var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = void 0;
const shared = require("@volar/shared");
const featureWorkers_1 = require("../utils/featureWorkers");
const dedupe = require("../utils/dedupe");
function register(context, api, isValidMapping, isValidMirrorPosition) {
    return (uri, position) => {
        return (0, featureWorkers_1.languageFeatureWorker)(context, uri, position, (position, map) => map.toGeneratedPositions(position, isValidMapping), (plugin, document, position) => __awaiter(this, void 0, void 0, function* () {
            const recursiveChecker = dedupe.createLocationSet();
            const result = [];
            yield withMirrors(document, position, undefined);
            return result;
            function withMirrors(document, position, originDefinition) {
                var _a, _b, _c, _d;
                return __awaiter(this, void 0, void 0, function* () {
                    const _api = api === 'findDefinition' ? (_a = plugin.definition) === null || _a === void 0 ? void 0 : _a.on :
                        api === 'findTypeDefinition' ? (_b = plugin.definition) === null || _b === void 0 ? void 0 : _b.onType :
                            api === 'findImplementations' ? plugin.findImplementations :
                                undefined;
                    if (!_api)
                        return;
                    if (recursiveChecker.has({ uri: document.uri, range: { start: position, end: position } }))
                        return;
                    recursiveChecker.add({ uri: document.uri, range: { start: position, end: position } });
                    const definitions = (_c = yield (_api === null || _api === void 0 ? void 0 : _api(document, position))) !== null && _c !== void 0 ? _c : [];
                    for (const definition of definitions) {
                        let foundMirrorPosition = false;
                        recursiveChecker.add({ uri: definition.targetUri, range: { start: definition.targetRange.start, end: definition.targetRange.start } });
                        const mirrorMap = (_d = context.documents.getMirrorMapByUri(definition.targetUri)) === null || _d === void 0 ? void 0 : _d[1];
                        if (mirrorMap) {
                            for (const mapped of mirrorMap.findMirrorPositions(definition.targetSelectionRange.start)) {
                                if (!isValidMirrorPosition(mapped[1]))
                                    continue;
                                if (recursiveChecker.has({ uri: mirrorMap.document.uri, range: { start: mapped[0], end: mapped[0] } }))
                                    continue;
                                foundMirrorPosition = true;
                                yield withMirrors(mirrorMap.document, mapped[0], originDefinition !== null && originDefinition !== void 0 ? originDefinition : definition);
                            }
                        }
                        if (!foundMirrorPosition) {
                            if (originDefinition) {
                                result.push(Object.assign(Object.assign({}, definition), { originSelectionRange: originDefinition.originSelectionRange }));
                            }
                            else {
                                result.push(definition);
                            }
                        }
                    }
                });
            }
        }), (data, sourceMap) => data.map(link => {
            if (link.originSelectionRange && sourceMap) {
                const originSelectionRange = toSourcePositionPreferSurroundedPosition(sourceMap, link.originSelectionRange, position);
                if (!originSelectionRange)
                    return;
                link.originSelectionRange = originSelectionRange;
            }
            let foundTargetSelectionRange = false;
            for (const [_, targetSourceMap] of context.documents.getMapsByVirtualFileUri(link.targetUri)) {
                const targetSelectionRange = targetSourceMap.toSourceRange(link.targetSelectionRange);
                if (!targetSelectionRange)
                    continue;
                foundTargetSelectionRange = true;
                let targetRange = targetSourceMap.toSourceRange(link.targetRange);
                link.targetUri = targetSourceMap.sourceFileDocument.uri;
                // loose range mapping to for template slots, slot properties
                link.targetRange = targetRange !== null && targetRange !== void 0 ? targetRange : targetSelectionRange;
                link.targetSelectionRange = targetSelectionRange;
            }
            if (context.documents.hasVirtualFileByUri(link.targetUri) && !foundTargetSelectionRange) {
                return;
            }
            return link;
        }).filter(shared.notEmpty), arr => dedupe.withLocationLinks(arr.flat()));
    };
}
exports.register = register;
function toSourcePositionPreferSurroundedPosition(map, mappedRange, position) {
    let result;
    for (const range of map.toSourceRanges(mappedRange)) {
        if (!result) {
            result = range;
        }
        if ((range.start.line < position.line || (range.start.line === position.line && range.start.character <= position.character))
            && (range.end.line > position.line || (range.end.line === position.line && range.end.character >= position.character))) {
            return range;
        }
    }
    return result;
}
//# sourceMappingURL=definition.js.map