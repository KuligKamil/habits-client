import {
  asRoutePath,
  joinPath,
  logTree,
  mergeRouteRecordOverride,
  resolveOptions,
  throttle,
  trimExtension,
  warn
} from "./chunk-A4S4FH4Y.mjs";
import {
  __spreadValues
} from "./chunk-D2LOKBOC.mjs";

// src/index.ts
import { createUnplugin } from "unplugin";

// src/core/treeNodeValue.ts
var EDITS_OVERRIDE_NAME = "@@edits";
var _TreeNodeValueBase = class {
  constructor(rawSegment, parent, pathSegment = rawSegment, subSegments = [pathSegment]) {
    this._overrides = /* @__PURE__ */ new Map();
    this.includeLoaderGuard = false;
    this.components = /* @__PURE__ */ new Map();
    this._type = 0;
    this.rawSegment = rawSegment;
    this.pathSegment = pathSegment;
    this.subSegments = subSegments;
    const parentPath = parent == null ? void 0 : parent.path;
    this.path = (!parentPath || parentPath === "/") && this.pathSegment === "" ? "/" : joinPath((parent == null ? void 0 : parent.path) || "", this.pathSegment);
  }
  toString() {
    return this.pathSegment || "<index>";
  }
  isParam() {
    return !!(this._type & 1 /* param */);
  }
  isStatic() {
    return this._type === 0 /* static */;
  }
  get overrides() {
    return [...this._overrides.entries()].sort(
      ([nameA], [nameB]) => nameA === nameB ? 0 : nameA !== EDITS_OVERRIDE_NAME && (nameA < nameB || nameB === EDITS_OVERRIDE_NAME) ? -1 : 1
    ).reduce((acc, [_path, routeBlock]) => {
      return mergeRouteRecordOverride(acc, routeBlock);
    }, {});
  }
  setOverride(path, routeBlock) {
    this._overrides.set(path, routeBlock || {});
  }
  removeOverride(key) {
    this._overrides.forEach((routeBlock) => {
      delete routeBlock[key];
    });
  }
  mergeOverride(path, routeBlock) {
    const existing = this._overrides.get(path) || {};
    this._overrides.set(path, mergeRouteRecordOverride(existing, routeBlock));
  }
  addEditOverride(routeBlock) {
    return this.mergeOverride(EDITS_OVERRIDE_NAME, routeBlock);
  }
  setEditOverride(key, value) {
    if (!this._overrides.has(EDITS_OVERRIDE_NAME)) {
      this._overrides.set(EDITS_OVERRIDE_NAME, {});
    }
    const existing = this._overrides.get(EDITS_OVERRIDE_NAME);
    existing[key] = value;
  }
};
var TreeNodeValueStatic = class extends _TreeNodeValueBase {
  constructor(rawSegment, parent, pathSegment = rawSegment) {
    super(rawSegment, parent, pathSegment);
    this._type = 0 /* static */;
  }
};
var TreeNodeValueParam = class extends _TreeNodeValueBase {
  constructor(rawSegment, parent, params, pathSegment, subSegments) {
    super(rawSegment, parent, pathSegment, subSegments);
    this._type = 1 /* param */;
    this.params = params;
  }
};
function createTreeNodeValue(segment, parent) {
  if (!segment || segment === "index") {
    return new TreeNodeValueStatic(segment, parent, "");
  }
  const [pathSegment, params, subSegments] = parseSegment(segment);
  if (params.length) {
    return new TreeNodeValueParam(
      segment,
      parent,
      params,
      pathSegment,
      subSegments
    );
  }
  return new TreeNodeValueStatic(segment, parent, pathSegment);
}
function parseSegment(segment) {
  let buffer = "";
  let state = 0 /* static */;
  const params = [];
  let pathSegment = "";
  const subSegments = [];
  let currentTreeRouteParam = createEmptyRouteParam();
  function consumeBuffer() {
    if (state === 0 /* static */) {
      pathSegment += buffer;
      subSegments.push(buffer);
    } else if (state === 3 /* modifier */) {
      currentTreeRouteParam.paramName = buffer;
      currentTreeRouteParam.modifier = currentTreeRouteParam.optional ? currentTreeRouteParam.repeatable ? "*" : "?" : currentTreeRouteParam.repeatable ? "+" : "";
      buffer = "";
      pathSegment += `:${currentTreeRouteParam.paramName}${currentTreeRouteParam.isSplat ? "(.*)" : ""}${currentTreeRouteParam.modifier}`;
      params.push(currentTreeRouteParam);
      subSegments.push(currentTreeRouteParam);
      currentTreeRouteParam = createEmptyRouteParam();
    }
    buffer = "";
  }
  for (let pos = 0; pos < segment.length; pos++) {
    const c = segment[pos];
    if (state === 0 /* static */) {
      if (c === "[") {
        consumeBuffer();
        state = 1 /* paramOptional */;
      } else {
        buffer += c === "." ? "/" : c;
      }
    } else if (state === 1 /* paramOptional */) {
      if (c === "[") {
        currentTreeRouteParam.optional = true;
      } else if (c === ".") {
        currentTreeRouteParam.isSplat = true;
        pos += 2;
      } else {
        buffer += c;
      }
      state = 2 /* param */;
    } else if (state === 2 /* param */) {
      if (c === "]") {
        if (currentTreeRouteParam.optional) {
          pos++;
        }
        state = 3 /* modifier */;
      } else if (c === ".") {
        currentTreeRouteParam.isSplat = true;
        pos += 2;
      } else {
        buffer += c;
      }
    } else if (state === 3 /* modifier */) {
      if (c === "+") {
        currentTreeRouteParam.repeatable = true;
      } else {
        pos--;
      }
      consumeBuffer();
      state = 0 /* static */;
    }
  }
  if (state === 2 /* param */ || state === 1 /* paramOptional */) {
    throw new Error(`Invalid segment: "${segment}"`);
  }
  if (buffer) {
    consumeBuffer();
  }
  return [pathSegment, params, subSegments];
}
function createEmptyRouteParam() {
  return {
    paramName: "",
    modifier: "",
    optional: false,
    repeatable: false,
    isSplat: false
  };
}

// src/core/tree.ts
var TreeNode = class {
  constructor(options, filePath, parent) {
    this.children = /* @__PURE__ */ new Map();
    this.hasDefinePage = false;
    this.options = options;
    this.parent = parent;
    this.value = createTreeNodeValue(filePath, parent == null ? void 0 : parent.value);
  }
  insert(path, filePath = path) {
    const { tail, segment, viewName, isComponent } = splitFilePath(
      path,
      this.options
    );
    if (!this.children.has(segment)) {
      this.children.set(segment, new TreeNode(this.options, segment, this));
    }
    const child = this.children.get(segment);
    if (isComponent) {
      child.value.components.set(viewName, filePath);
    }
    if (tail) {
      return child.insert(tail, filePath);
    }
    return child;
  }
  setCustomRouteBlock(path, routeBlock) {
    this.value.setOverride(path, routeBlock);
  }
  getSortedChildren() {
    return Array.from(this.children.values()).sort(
      (a, b) => a.path.localeCompare(b.path)
    );
  }
  delete() {
    if (!this.parent) {
      throw new Error("Cannot delete the root node.");
    }
    this.parent.children.delete(this.value.rawSegment);
    this.parent = void 0;
  }
  remove(path) {
    const { tail, segment, viewName, isComponent } = splitFilePath(
      path,
      this.options
    );
    const child = this.children.get(segment);
    if (!child) {
      throw new Error(
        `Cannot Delete "${path}". "${segment}" not found at "${this.path}".`
      );
    }
    if (tail) {
      child.remove(tail);
      if (child.children.size === 0 && child.value.components.size === 0) {
        this.children.delete(segment);
      }
    } else {
      if (isComponent) {
        child.value.components.delete(viewName);
      }
      if (child.children.size === 0 && child.value.components.size === 0) {
        this.children.delete(segment);
      }
    }
  }
  get path() {
    var _a, _b;
    return (_b = this.value.overrides.path) != null ? _b : (((_a = this.parent) == null ? void 0 : _a.isRoot()) ? "/" : "") + this.value.pathSegment;
  }
  get fullPath() {
    var _a;
    return (_a = this.value.overrides.path) != null ? _a : this.value.path;
  }
  get name() {
    return this.value.overrides.name || this.options.getRouteName(this);
  }
  get metaAsObject() {
    const meta = __spreadValues({}, this.value.overrides.meta);
    if (this.value.includeLoaderGuard) {
      meta._loaderGuard = true;
    }
    return meta;
  }
  get meta() {
    const overrideMeta = this.metaAsObject;
    return Object.keys(overrideMeta).length > 0 ? JSON.stringify(overrideMeta, null, 2) : "";
  }
  get params() {
    const params = this.value.isParam() ? [...this.value.params] : [];
    let node = this.parent;
    while (node) {
      if (node.value.isParam()) {
        params.unshift(...node.value.params);
      }
      node = node.parent;
    }
    return params;
  }
  isRoot() {
    return this.value.path === "/" && !this.value.components.size;
  }
  toString() {
    return `${this.value}${this.value.components.size > 1 || this.value.components.size === 1 && !this.value.components.get("default") ? ` \u2388(${Array.from(this.value.components.keys()).join(", ")})` : ""}${this.hasDefinePage ? " \u2691 definePage()" : ""}`;
  }
};
var PrefixTree = class extends TreeNode {
  constructor(options) {
    super(options, "");
    this.map = /* @__PURE__ */ new Map();
  }
  insert(path, filePath = path) {
    const node = super.insert(path, filePath);
    this.map.set(filePath, node);
    return node;
  }
  getChild(filePath) {
    return this.map.get(filePath);
  }
  removeChild(filePath) {
    if (this.map.has(filePath)) {
      this.map.get(filePath).delete();
      this.map.delete(filePath);
    }
  }
};
function createPrefixTree(options) {
  return new PrefixTree(options);
}
function splitFilePath(filePath, options) {
  const slashPos = filePath.indexOf("/");
  let head = slashPos < 0 ? filePath : filePath.slice(0, slashPos);
  const tail = slashPos < 0 ? "" : filePath.slice(slashPos + 1);
  let segment = head;
  if (!tail) {
    segment = trimExtension(head, options.extensions);
  }
  let viewName = "default";
  const namedSeparatorPos = segment.indexOf("@");
  if (namedSeparatorPos > 0) {
    viewName = segment.slice(namedSeparatorPos + 1);
    segment = segment.slice(0, namedSeparatorPos);
  }
  const isComponent = segment !== head;
  return {
    segment,
    tail,
    viewName,
    isComponent
  };
}

// src/core/context.ts
import { promises as fs3 } from "fs";

// src/codegen/generateRouteParams.ts
function generateRouteParams(node, isRaw) {
  const nodeParams = node.params;
  return node.params.length > 0 ? `{ ${node.params.map(
    (param) => `${param.paramName}${param.optional ? "?" : ""}: ` + (param.modifier === "+" ? `ParamValueOneOrMore<${isRaw}>` : param.modifier === "*" ? `ParamValueZeroOrMore<${isRaw}>` : param.modifier === "?" ? `ParamValueZeroOrOne<${isRaw}>` : `ParamValue<${isRaw}>`)
  ).join(", ")} }` : "Record<never, never>";
}

// src/codegen/generateRouteMap.ts
function generateRouteNamedMap(node) {
  if (node.isRoot()) {
    return `export interface RouteNamedMap {
${node.getSortedChildren().map(generateRouteNamedMap).join("")}}`;
  }
  return (node.value.components.size ? `  '${node.name}': ${generateRouteRecordInfo(node)},
` : "") + (node.children.size > 0 ? node.getSortedChildren().map(generateRouteNamedMap).join("\n") : "");
}
function generateRouteRecordInfo(node) {
  return `RouteRecordInfo<'${node.name}', '${node.fullPath}', ${generateRouteParams(node, true)}, ${generateRouteParams(node, false)}>`;
}

// src/core/moduleConstants.ts
var MODULE_VUE_ROUTER = "vue-router/auto";
var MODULE_ROUTES_PATH = `${MODULE_VUE_ROUTER}/routes`;
var VIRTUAL_PREFIX = "virtual:";
var ROUTE_BLOCK_ID = `${VIRTUAL_PREFIX}/vue-router/auto/route-block`;
function getVirtualId(id) {
  return id.startsWith(VIRTUAL_PREFIX) ? id.slice(VIRTUAL_PREFIX.length) : null;
}
var routeBlockQueryRE = /\?vue&type=route/;
function asVirtualId(id) {
  return VIRTUAL_PREFIX + id;
}

// src/codegen/generateRouteRecords.ts
function generateRouteRecord(node, options, importList, indent = 0) {
  if (node.value.path === "/" && indent === 0) {
    return `[
${node.getSortedChildren().map((child) => generateRouteRecord(child, options, importList, indent + 1)).join(",\n")}
]`;
  }
  const startIndent = " ".repeat(indent * 2);
  const indentStr = " ".repeat((indent + 1) * 2);
  const overrides = node.value.overrides;
  const routeRecord = `${startIndent}{
${indentStr}path: '${node.path}',
${indentStr}${node.value.components.size ? `name: '${node.name}',` : `/* internal name: '${node.name}' */`}
${indentStr}${node.value.components.size ? generateRouteRecordComponent(
    node,
    indentStr,
    options.importMode,
    importList
  ) : "/* no component */"}
${overrides.props != null ? indentStr + `props: ${overrides.props},
` : ""}${overrides.alias != null ? indentStr + `alias: ${JSON.stringify(overrides.alias)},
` : ""}${indentStr}${node.children.size > 0 ? `children: [
${node.getSortedChildren().map((child) => generateRouteRecord(child, options, importList, indent + 2)).join(",\n")}
${indentStr}],` : "/* no children */"}${formatMeta(node, indentStr)}
${startIndent}}`;
  if (node.hasDefinePage) {
    const definePageDataList = [];
    for (const [name, filePath] of node.value.components) {
      const pageDataImport = `_definePage_${name}_${importList.size}`;
      definePageDataList.push(pageDataImport);
      importList.set(pageDataImport, `${filePath}?definePage&vue`);
    }
    if (definePageDataList.length) {
      return `  _mergeRouteRecord(
${routeRecord},
  ${definePageDataList.join(",\n")}
  )`;
    }
  }
  return routeRecord;
}
function generateRouteRecordComponent(node, indentStr, importMode, importList) {
  const files = Array.from(node.value.components);
  const isDefaultExport = files.length === 1 && files[0][0] === "default";
  return isDefaultExport ? `component: ${generatePageImport(files[0][1], importMode, importList)},` : `components: {
${files.map(
    ([key, path]) => `${indentStr + "  "}'${key}': ${generatePageImport(
      path,
      importMode,
      importList
    )}`
  ).join(",\n")}
${indentStr}},`;
}
function generatePageImport(filepath, importMode, importList) {
  const mode = typeof importMode === "function" ? importMode(filepath) : importMode;
  if (mode === "async") {
    return `() => import('${filepath}')`;
  } else {
    const importName = `_page_${importList.size}`;
    importList.set(importName, filepath);
    return importName;
  }
}
function generateImportList(node, indentStr) {
  const files = Array.from(node.value.components);
  return `[
${files.map(([_key, path]) => `${indentStr}  () => import('${path}')`).join(",\n")}
${indentStr}]`;
}
var LOADER_GUARD_RE = /['"]_loaderGuard['"]:.*$/;
function formatMeta(node, indent) {
  const meta = node.meta;
  const formatted = meta && meta.split("\n").map(
    (line) => indent + line.replace(
      LOADER_GUARD_RE,
      "[_HasDataLoaderMeta]: " + generateImportList(node, indent + "  ") + ","
    )
  ).join("\n");
  return formatted ? "\n" + indent + "meta: " + formatted.trimStart() : "";
}

// src/core/context.ts
import fg from "fast-glob";
import { resolve } from "pathe";

// src/core/customBlock.ts
import { parse } from "@vue/compiler-sfc";
import { promises as fs } from "fs";
import JSON5 from "json5";
import { parse as YAMLParser } from "yaml";
async function getRouteBlock(path, options) {
  const content = await fs.readFile(path, "utf8");
  const parsedSFC = await parse(content, { pad: "space" }).descriptor;
  const blockStr = parsedSFC == null ? void 0 : parsedSFC.customBlocks.find((b) => b.type === "route");
  if (!blockStr)
    return;
  let result = parseCustomBlock(blockStr, path, options);
  if (result) {
    if (result.path != null && !result.path.startsWith("/")) {
      warn(`Overridden path must start with "/". Found in "${path}".`);
    }
  }
  return result;
}
function parseCustomBlock(block, filePath, options) {
  var _a;
  const lang = (_a = block.lang) != null ? _a : options.routeBlockLang;
  if (lang === "json5") {
    try {
      return JSON5.parse(block.content);
    } catch (err) {
      warn(
        `Invalid JSON5 format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "json") {
    try {
      return JSON.parse(block.content);
    } catch (err) {
      warn(
        `Invalid JSON format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else if (lang === "yaml" || lang === "yml") {
    try {
      return YAMLParser(block.content);
    } catch (err) {
      warn(
        `Invalid YAML format of <${block.type}> content in ${filePath}
${err.message}`
      );
    }
  } else {
    warn(
      `Language "${lang}" for <${block.type}> is not supported. Supported languages are: json5, json, yaml, yml. Found in in ${filePath}.`
    );
  }
}

// src/core/RoutesFolderWatcher.ts
import chokidar from "chokidar";
import { normalize } from "pathe";
var RoutesFolderWatcher = class {
  constructor(routesFolder, options) {
    this.src = routesFolder.src;
    this.pathPrefix = routesFolder.path || "";
    this.options = options;
    this.watcher = chokidar.watch(this.src, {
      ignoreInitial: true,
      ignorePermissionErrors: true,
      ignored: options.exclude
    });
  }
  on(event, handler) {
    this.watcher.on(event, (filePath) => {
      filePath = normalize(filePath);
      if (this.options.extensions.every(
        (extension) => !filePath.endsWith(extension)
      )) {
        return;
      }
      handler({
        filePath,
        routePath: asRoutePath(
          { src: this.src, path: this.pathPrefix },
          filePath
        )
      });
    });
    return this;
  }
  close() {
    this.watcher.close();
  }
};

// src/codegen/generateDTS.ts
function generateDTS({
  vueRouterModule,
  routesModule,
  routeNamedMap
}) {
  return `// Generated by unplugin-vue-router. \u203C\uFE0F DO NOT MODIFY THIS FILE \u203C\uFE0F
// It's recommended to commit this file.
// Make sure to add this file to your tsconfig.json file as an "includes" or "files" entry.

/// <reference types="unplugin-vue-router/client" />

import type {
  // type safe route locations
  RouteLocationTypedList,
  RouteLocationResolvedTypedList,
  RouteLocationNormalizedTypedList,
  RouteLocationNormalizedLoadedTypedList,
  RouteLocationAsString,
  RouteLocationAsRelativeTypedList,
  RouteLocationAsPathTypedList,

  // helper types
  // route definitions
  RouteRecordInfo,
  ParamValue,
  ParamValueOneOrMore,
  ParamValueZeroOrMore,
  ParamValueZeroOrOne,

  // vue-router extensions
  _RouterTyped,
  RouterLinkTyped,
  NavigationGuard,
  UseLinkFnTyped,

  // data fetching
  _DataLoader,
  _DefineLoaderOptions,
} from 'unplugin-vue-router'

declare module '${routesModule}' {
${routeNamedMap}
}

declare module '${vueRouterModule}' {
  import type { RouteNamedMap } from '${routesModule}'

  export type RouterTyped = _RouterTyped<RouteNamedMap>

  /**
   * Type safe version of \`RouteLocationNormalized\` (the type of \`to\` and \`from\` in navigation guards).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationNormalized<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationNormalizedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationNormalizedLoaded\` (the return type of \`useRoute()\`).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationNormalizedLoaded<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationResolved\` (the returned route of \`router.resolve()\`).
   * Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationResolved<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationResolvedTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocation\` . Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocation<Name extends keyof RouteNamedMap = keyof RouteNamedMap> = RouteLocationTypedList<RouteNamedMap>[Name]

  /**
   * Type safe version of \`RouteLocationRaw\` . Allows passing the name of the route to be passed as a generic.
   */
  export type RouteLocationRaw<Name extends keyof RouteNamedMap = keyof RouteNamedMap> =
    | RouteLocationAsString<RouteNamedMap>
    | RouteLocationAsRelativeTypedList<RouteNamedMap>[Name]
    | RouteLocationAsPathTypedList<RouteNamedMap>[Name]

  /**
   * Generate a type safe params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParams<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['params']
  /**
   * Generate a type safe raw params for a route location. Requires the name of the route to be passed as a generic.
   */
  export type RouteParamsRaw<Name extends keyof RouteNamedMap> = RouteNamedMap[Name]['paramsRaw']

  export function useRouter(): RouterTyped
  export function useRoute<Name extends keyof RouteNamedMap = keyof RouteNamedMap>(name?: Name): RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[Name]

  export const useLink: UseLinkFnTyped<RouteNamedMap>

  export function onBeforeRouteLeave(guard: NavigationGuard<RouteNamedMap>): void
  export function onBeforeRouteUpdate(guard: NavigationGuard<RouteNamedMap>): void

  export const RouterLink: RouterLinkTyped<RouteNamedMap>
  
  // Experimental Data Fetching

  export function defineLoader<
    P extends Promise<any>,
    Name extends keyof RouteNamedMap = keyof RouteNamedMap,
    isLazy extends boolean = false,
  >(
    name: Name,
    loader: (route: RouteLocationNormalizedLoaded<Name>) => P,
    options?: _DefineLoaderOptions<isLazy>,
  ): _DataLoader<Awaited<P>, isLazy>
  export function defineLoader<
    P extends Promise<any>,
    isLazy extends boolean = false,
  >(
    loader: (route: RouteLocationNormalizedLoaded) => P,
    options?: _DefineLoaderOptions<isLazy>,
  ): _DataLoader<Awaited<P>, isLazy>

  export {
    _definePage as definePage,
    _HasDataLoaderMeta as HasDataLoaderMeta,
    _setupDataFetchingGuard as setupDataFetchingGuard,
    _stopDataFetchingScope as stopDataFetchingScope,
  } from 'unplugin-vue-router/runtime'
}

declare module 'vue-router' {
  import type { RouteNamedMap } from '${routesModule}'

  export interface TypesConfig {
    beforeRouteUpdate: NavigationGuard<RouteNamedMap>
    beforeRouteLeave: NavigationGuard<RouteNamedMap>

    $route: RouteLocationNormalizedLoadedTypedList<RouteNamedMap>[keyof RouteNamedMap]
    $router: _RouterTyped<RouteNamedMap>

    RouterLink: RouterLinkTyped<RouteNamedMap>
  }
}
`;
}

// src/codegen/vueRouterModule.ts
function generateVueRouterProxy(routesModule, options) {
  return `
import { routes } from '${routesModule}'
import { createRouter as _createRouter } from 'vue-router'

export * from 'vue-router'
export {
  _defineLoader as defineLoader,
  _definePage as definePage,
  _HasDataLoaderMeta as HasDataLoaderMeta,
  _setupDataFetchingGuard as setupDataFetchingGuard,
  _stopDataFetchingScope as stopDataFetchingScope,
} from 'unplugin-vue-router/runtime'

export function createRouter(options) {
  const { extendRoutes } = options
  // use Object.assign for better browser support
  const router = _createRouter(Object.assign(
    options,
    { routes: typeof extendRoutes === 'function' ? extendRoutes(routes) : routes },
  ))

  return router
}
`;
}

// src/data-fetching/parse.ts
import { promises as fs2 } from "fs";
import { findExports } from "mlly";
async function hasNamedExports(file) {
  const code = await fs2.readFile(file, "utf8");
  const exportedNames = findExports(code).filter(
    (e) => e.type !== "default" && e.type !== "star"
  );
  return exportedNames.length > 0;
}

// src/core/definePage.ts
import {
  getTransformResult,
  isCallOf,
  parseSFC,
  MagicString,
  checkInvalidScopeReference
} from "@vue-macros/common";
import { walkAST } from "ast-walker-scope";
var MACRO_DEFINE_PAGE = "definePage";
var MACRO_DEFINE_PAGE_QUERY = /[?&]definePage\b/;
function definePageTransform({
  code,
  id
}) {
  if (!code.includes(MACRO_DEFINE_PAGE))
    return;
  const sfc = parseSFC(code, id);
  if (!sfc.scriptSetup)
    return;
  const isExtractingDefinePage = MACRO_DEFINE_PAGE_QUERY.test(id);
  const { script, scriptSetup, getSetupAst } = sfc;
  const setupAst = getSetupAst();
  const definePageNodes = ((setupAst == null ? void 0 : setupAst.body) || []).map((node) => {
    if (node.type === "ExpressionStatement")
      node = node.expression;
    return isCallOf(node, MACRO_DEFINE_PAGE) ? node : null;
  }).filter((node) => !!node);
  if (!definePageNodes.length) {
    return isExtractingDefinePage ? "export default {}" : null;
  } else if (definePageNodes.length > 1) {
    throw new SyntaxError(`duplicate definePage() call`);
  }
  const definePageNode = definePageNodes[0];
  const setupOffset = scriptSetup.loc.start.offset;
  if (isExtractingDefinePage) {
    const s = new MagicString(code);
    const routeRecord = definePageNode.arguments[0];
    const scriptBindings = (setupAst == null ? void 0 : setupAst.body) ? getIdentifiers(setupAst.body) : [];
    checkInvalidScopeReference(routeRecord, MACRO_DEFINE_PAGE, scriptBindings);
    s.remove(setupOffset + routeRecord.end, code.length);
    s.remove(0, setupOffset + routeRecord.start);
    s.prepend(`export default `);
    return getTransformResult(s, id);
  } else {
    const s = new MagicString(code);
    s.remove(
      setupOffset + definePageNode.start,
      setupOffset + definePageNode.end
    );
    return getTransformResult(s, id);
  }
}
function extractDefinePageNameAndPath(sfcCode, id) {
  var _a;
  if (!sfcCode.includes(MACRO_DEFINE_PAGE))
    return;
  const sfc = parseSFC(sfcCode, id);
  if (!sfc.scriptSetup)
    return;
  const { getSetupAst } = sfc;
  const setupAst = getSetupAst();
  const definePageNodes = ((_a = setupAst == null ? void 0 : setupAst.body) != null ? _a : []).map((node) => {
    if (node.type === "ExpressionStatement")
      node = node.expression;
    return isCallOf(node, MACRO_DEFINE_PAGE) ? node : null;
  }).filter((node) => !!node);
  if (!definePageNodes.length) {
    return;
  } else if (definePageNodes.length > 1) {
    throw new SyntaxError(`duplicate definePage() call`);
  }
  const definePageNode = definePageNodes[0];
  const routeRecord = definePageNode.arguments[0];
  if (routeRecord.type !== "ObjectExpression") {
    throw new SyntaxError(
      `[${id}]: definePage() expects an object expression as its only argument`
    );
  }
  const routeInfo = {};
  for (const prop of routeRecord.properties) {
    if (prop.type === "ObjectProperty" && prop.key.type === "Identifier") {
      if (prop.key.name === "name") {
        if (prop.value.type !== "StringLiteral") {
          warn(`route name must be a string literal. Found in "${id}".`);
        } else {
          routeInfo.name = prop.value.value;
        }
      } else if (prop.key.name === "path") {
        if (prop.value.type !== "StringLiteral") {
          warn(`route path must be a string literal. Found in "${id}".`);
        } else {
          routeInfo.path = prop.value.value;
        }
      }
    }
  }
  return routeInfo;
}
var getIdentifiers = (stmts) => {
  let ids = [];
  walkAST(
    {
      type: "Program",
      body: stmts,
      directives: [],
      sourceType: "module",
      sourceFile: ""
    },
    {
      enter(node) {
        if (node.type === "BlockStatement") {
          this.skip();
        }
      },
      leave(node) {
        if (node.type !== "Program")
          return;
        ids = Object.keys(this.scope);
      }
    }
  );
  return ids;
};

// src/core/extendRoutes.ts
var EditableTreeNode = class {
  constructor(node) {
    this.node = node;
  }
  delete() {
    return this.node.delete();
  }
  insert(path, filePath) {
    const extDotIndex = filePath.lastIndexOf(".");
    const ext = filePath.slice(extDotIndex);
    if (!path.endsWith(ext)) {
      path += ext;
    }
    let addBackLeadingSlash = false;
    if (path.startsWith("/")) {
      path = path.slice(1);
      addBackLeadingSlash = !this.node.isRoot();
    }
    const node = this.node.insert(path, filePath);
    const editable = new EditableTreeNode(node);
    if (addBackLeadingSlash) {
      editable.path = "/" + node.path;
    }
    return editable;
  }
  get parent() {
    return this.node.parent && new EditableTreeNode(this.node.parent);
  }
  get components() {
    return this.node.value.components;
  }
  get name() {
    return this.node.name;
  }
  set name(name) {
    this.node.value.addEditOverride({ name });
  }
  get isPassThrough() {
    return this.node.value.components.size === 0;
  }
  get meta() {
    return this.node.metaAsObject;
  }
  set meta(meta) {
    this.node.value.removeOverride("meta");
    this.node.value.setEditOverride("meta", meta);
  }
  addToMeta(meta) {
    this.node.value.addEditOverride({ meta });
  }
  get path() {
    return this.node.path;
  }
  set path(path) {
    if (!path.startsWith("/")) {
      warn(
        `Only absolute paths are supported. Make sure that "${path}" starts with a slash "/".`
      );
      return;
    }
    this.node.value.addEditOverride({ path });
  }
  get alias() {
    return this.node.value.overrides.alias;
  }
  addAlias(alias) {
    this.node.value.addEditOverride({ alias });
  }
  get params() {
    return this.node.params;
  }
  get fullPath() {
    return this.node.fullPath;
  }
  *traverseDFS() {
    if (!this.node.isRoot()) {
      yield this;
    }
    for (const [_name, child] of this.node.children) {
      yield* new EditableTreeNode(child).traverseDFS();
    }
  }
  *[Symbol.iterator]() {
    yield* this.traverseBFS();
  }
  *traverseBFS() {
    for (const [_name, child] of this.node.children) {
      yield new EditableTreeNode(child);
    }
    for (const [_name, child] of this.node.children) {
      yield* new EditableTreeNode(child).traverseBFS();
    }
  }
};

// src/core/context.ts
function createRoutesContext(options) {
  const { dts: preferDTS, root, routesFolder } = options;
  const dts = preferDTS === false ? false : preferDTS === true ? resolve(root, "typed-router.d.ts") : resolve(root, preferDTS);
  const routeTree = createPrefixTree(options);
  const editableRoutes = new EditableTreeNode(routeTree);
  function log(...args) {
    if (options.logs) {
      console.log(...args);
    }
  }
  const watchers = [];
  async function scanPages(startWatchers = true) {
    var _a;
    if (options.extensions.length < 1) {
      throw new Error(
        '"extensions" cannot be empty. Please specify at least one extension.'
      );
    }
    if (watchers.length > 0) {
      return;
    }
    const pattern = `**/*` + (options.extensions.length === 1 ? options.extensions[0] : `.{${options.extensions.map((extension) => extension.replace(".", "")).join(",")}}`);
    await Promise.all(
      routesFolder.map((folder) => {
        const watcher = new RoutesFolderWatcher(folder, options);
        setupWatcher(watcher);
        watchers.push(watcher);
        return fg(pattern, {
          cwd: folder.src,
          ignore: options.exclude
        }).then((files) => files.map((file) => resolve(folder.src, file))).then(
          (files) => Promise.all(
            files.map(
              (file) => addPage({
                routePath: asRoutePath(folder, file),
                filePath: file
              })
            )
          )
        );
      })
    );
    for (const route of editableRoutes) {
      await ((_a = options.extendRoute) == null ? void 0 : _a.call(options, route));
    }
    await _writeConfigFiles();
  }
  async function writeRouteInfoToNode(node, path) {
    const content = await fs3.readFile(path, "utf8");
    node.hasDefinePage = content.includes("definePage");
    const [definedPageNameAndPath, routeBlock] = await Promise.all([
      extractDefinePageNameAndPath(content, path),
      getRouteBlock(path, options)
    ]);
    node.setCustomRouteBlock(path, __spreadValues(__spreadValues({}, routeBlock), definedPageNameAndPath));
    node.value.includeLoaderGuard = options.dataFetching && await hasNamedExports(path);
  }
  async function addPage({ filePath, routePath }, triggerExtendRoute = false) {
    var _a;
    log(`added "${routePath}" for "${filePath}"`);
    const node = routeTree.insert(routePath, filePath);
    await writeRouteInfoToNode(node, filePath);
    if (triggerExtendRoute) {
      await ((_a = options.extendRoute) == null ? void 0 : _a.call(options, new EditableTreeNode(node)));
    }
  }
  async function updatePage({ filePath, routePath }) {
    var _a;
    log(`updated "${routePath}" for "${filePath}"`);
    const node = routeTree.getChild(filePath);
    if (!node) {
      console.warn(`Cannot update "${filePath}": Not found.`);
      return;
    }
    await writeRouteInfoToNode(node, filePath);
    await ((_a = options.extendRoute) == null ? void 0 : _a.call(options, new EditableTreeNode(node)));
  }
  function removePage({ filePath, routePath }) {
    log(`remove "${routePath}" for "${filePath}"`);
    routeTree.removeChild(filePath);
  }
  function setupWatcher(watcher) {
    log(`\u{1F916} Scanning files in ${watcher.src}`);
    watcher.on("change", async (ctx) => {
      await updatePage(ctx);
      writeConfigFiles();
    }).on("add", async (ctx) => {
      await addPage(ctx, true);
      writeConfigFiles();
    }).on("unlink", async (ctx) => {
      await removePage(ctx);
      writeConfigFiles();
    });
  }
  function generateRoutes() {
    const importList = /* @__PURE__ */ new Map();
    const routesExport = `export const routes = ${generateRouteRecord(
      routeTree,
      options,
      importList
    )}`;
    let imports = "";
    if (true) {
      imports += `import { _HasDataLoaderMeta, _mergeRouteRecord } from 'unplugin-vue-router/runtime'
`;
    }
    for (const [name, path] of importList) {
      imports += `import ${name} from '${path}'
`;
    }
    if (imports) {
      imports += "\n";
    }
    return `${imports}${routesExport}
`;
  }
  function generateDTS2() {
    return generateDTS({
      vueRouterModule: MODULE_VUE_ROUTER,
      routesModule: MODULE_ROUTES_PATH,
      routeNamedMap: generateRouteNamedMap(routeTree).split("\n").filter((line) => line).map((line) => "  " + line).join("\n")
    });
  }
  function generateVueRouterProxy2() {
    return generateVueRouterProxy(MODULE_ROUTES_PATH, options);
  }
  let lastDTS;
  async function _writeConfigFiles() {
    log("\u{1F4BE} writing...");
    if (options.beforeWriteFiles) {
      await options.beforeWriteFiles(editableRoutes);
    }
    logTree(routeTree, log);
    if (dts) {
      const content = generateDTS2();
      if (lastDTS !== content) {
        await fs3.writeFile(dts, content, "utf-8");
        lastDTS = content;
        server == null ? void 0 : server.invalidate(MODULE_ROUTES_PATH);
        server == null ? void 0 : server.invalidate(MODULE_VUE_ROUTER);
        server == null ? void 0 : server.reload();
      }
    }
  }
  const writeConfigFiles = throttle(_writeConfigFiles, 500, 100);
  function stopWatcher() {
    watchers.forEach((watcher) => watcher.close());
  }
  let server;
  function setServerContext(_server) {
    server = _server;
  }
  return {
    scanPages,
    writeConfigFiles,
    setServerContext,
    stopWatcher,
    generateRoutes,
    generateVueRouterProxy: generateVueRouterProxy2,
    definePageTransform(code, id) {
      return definePageTransform({
        code,
        id
      });
    }
  };
}

// src/core/vite/index.ts
function createViteContext(server) {
  function invalidate(path) {
    const { moduleGraph } = server;
    const foundModule = moduleGraph.getModuleById(asVirtualId(path));
    if (foundModule) {
      moduleGraph.invalidateModule(foundModule);
    }
    return !!foundModule;
  }
  function reload() {
    if (server.ws) {
      server.ws.send({
        type: "full-reload",
        path: "*"
      });
    }
  }
  return {
    invalidate,
    reload
  };
}

// src/index.ts
import { createFilter } from "@rollup/pluginutils";
import { join } from "pathe";
var src_default = createUnplugin((opt = {}, meta) => {
  const options = resolveOptions(opt);
  const ctx = createRoutesContext(options);
  function getVirtualId2(id) {
    if (options._inspect)
      return id;
    return getVirtualId(id);
  }
  function asVirtualId2(id) {
    if (options._inspect)
      return id;
    return asVirtualId(id);
  }
  const pageFilePattern = `**/*` + (options.extensions.length === 1 ? options.extensions[0] : `.{${options.extensions.map((extension) => extension.replace(".", "")).join(",")}}`);
  const filterPageComponents = createFilter(
    [
      ...options.routesFolder.map(
        (routeOption) => join(routeOption.src, pageFilePattern)
      ),
      /definePage\&vue$/
    ],
    options.exclude
  );
  return {
    name: "unplugin-vue-router",
    enforce: "pre",
    resolveId(id) {
      if (id === MODULE_ROUTES_PATH) {
        return asVirtualId2(id);
      }
      if (id === MODULE_VUE_ROUTER) {
        return asVirtualId2(id);
      }
      if (routeBlockQueryRE.test(id)) {
        return ROUTE_BLOCK_ID;
      }
    },
    buildStart() {
      return ctx.scanPages();
    },
    buildEnd() {
      if (options.logs) {
        console.log("\u{1F6D1} stopping watcher");
      }
      ctx.stopWatcher();
    },
    transformInclude(id) {
      return filterPageComponents(id);
    },
    transform(code, id) {
      return ctx.definePageTransform(code, id);
    },
    loadInclude(id) {
      if (id === ROUTE_BLOCK_ID)
        return true;
      const resolvedId = getVirtualId2(id);
      return resolvedId === MODULE_ROUTES_PATH || resolvedId === MODULE_VUE_ROUTER;
    },
    load(id) {
      if (id === ROUTE_BLOCK_ID) {
        return {
          code: `export default {}`,
          map: null
        };
      }
      const resolvedId = getVirtualId2(id);
      if (resolvedId === MODULE_ROUTES_PATH) {
        return ctx.generateRoutes();
      }
      if (resolvedId === MODULE_VUE_ROUTER) {
        return ctx.generateVueRouterProxy();
      }
    },
    vite: {
      configureServer(server) {
        ctx.setServerContext(createViteContext(server));
      }
    }
  };
});
var VueRouterExports = [
  "useRoute",
  "useRouter",
  "defineLoader",
  "onBeforeRouteUpdate",
  "onBeforeRouteLeave"
];
var VueRouterAutoImports = {
  "vue-router/auto": VueRouterExports,
  "unplugin-vue-router/runtime": [["_definePage", "definePage"]]
};

export {
  TreeNodeValueStatic,
  TreeNodeValueParam,
  createTreeNodeValue,
  TreeNode,
  createPrefixTree,
  createRoutesContext,
  src_default,
  VueRouterExports,
  VueRouterAutoImports
};
