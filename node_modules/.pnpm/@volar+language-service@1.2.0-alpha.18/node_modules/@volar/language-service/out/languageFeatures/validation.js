var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.register = exports.updateRange = void 0;
const shared = require("@volar/shared");
const vscode = require("vscode-languageserver-protocol");
const dedupe = require("../utils/dedupe");
const featureWorkers_1 = require("../utils/featureWorkers");
function updateRange(range, change) {
    if (!updatePosition(range.start, change, false)) {
        return;
    }
    if (!updatePosition(range.end, change, true)) {
        return;
    }
    if (range.end.line === range.start.line && range.end.character <= range.start.character) {
        range.end.character++;
    }
    return range;
}
exports.updateRange = updateRange;
function updatePosition(position, change, isEnd) {
    if (change.range.end.line > position.line) {
        if (change.newEnd.line > position.line) {
            // No change
            return true;
        }
        else if (change.newEnd.line === position.line) {
            position.character = Math.min(position.character, change.newEnd.character);
            return true;
        }
        else if (change.newEnd.line < position.line) {
            position.line = change.newEnd.line;
            position.character = change.newEnd.character;
            return true;
        }
    }
    else if (change.range.end.line === position.line) {
        const characterDiff = change.newEnd.character - change.range.end.character;
        if (position.character >= change.range.end.character) {
            if (change.newEnd.line !== change.range.end.line) {
                position.line = change.newEnd.line;
                position.character = change.newEnd.character + position.character - change.range.end.character;
            }
            else {
                if (isEnd ? change.range.end.character < position.character : change.range.end.character <= position.character) {
                    position.character += characterDiff;
                }
                else {
                    const offset = change.range.end.character - position.character;
                    if (-characterDiff > offset) {
                        position.character += characterDiff + offset;
                    }
                }
            }
            return true;
        }
        else {
            if (change.newEnd.line === change.range.end.line) {
                const offset = change.range.end.character - position.character;
                if (-characterDiff > offset) {
                    position.character += characterDiff + offset;
                }
            }
            else if (change.newEnd.line < change.range.end.line) {
                position.line = change.newEnd.line;
                position.character = change.newEnd.character;
            }
            else {
                // No change
            }
            return true;
        }
    }
    else if (change.range.end.line < position.line) {
        position.line += change.newEnd.line - change.range.end.line;
        return true;
    }
    return false;
}
function register(context) {
    const lastResponses = new Map();
    const cacheMaps = {
        semantic: new Map(),
        declaration: new Map(),
        syntactic: new Map(),
        suggestion: new Map(),
        semantic_rules: new Map(),
        syntax_rules: new Map(),
        format_rules: new Map(),
    };
    return (uri, token, response) => __awaiter(this, void 0, void 0, function* () {
        var _a;
        const newDocument = context.getTextDocument(uri);
        if (!newDocument) {
            return [];
        }
        const lastResponse = (_a = lastResponses.get(uri)) !== null && _a !== void 0 ? _a : lastResponses.set(uri, {
            semantic: { errors: [] },
            declaration: { errors: [] },
            suggestion: { errors: [] },
            syntactic: { errors: [] },
            semantic_rules: { errors: [] },
            syntax_rules: { errors: [] },
            format_rules: { errors: [] },
        }).get(uri);
        const newSnapshot = context.host.getScriptSnapshot(shared.uriToFileName(uri));
        let updateCacheRangeFailed = false;
        let errorsUpdated = false;
        let lastCheckCancelAt = 0;
        for (const cache of Object.values(lastResponse)) {
            const oldSnapshot = cache.snapshot;
            const oldDocument = cache.document;
            const change = oldSnapshot ? newSnapshot === null || newSnapshot === void 0 ? void 0 : newSnapshot.getChangeRange(oldSnapshot) : undefined;
            cache.snapshot = newSnapshot;
            cache.document = newDocument;
            if (!updateCacheRangeFailed && newDocument && oldSnapshot && oldDocument && newSnapshot && change) {
                const changeRange = {
                    range: {
                        start: oldDocument.positionAt(change.span.start),
                        end: oldDocument.positionAt(change.span.start + change.span.length),
                    },
                    newEnd: newDocument.positionAt(change.span.start + change.newLength),
                };
                for (const error of cache.errors) {
                    if (!updateRange(error.range, changeRange)) {
                        updateCacheRangeFailed = true;
                        break;
                    }
                }
            }
        }
        yield lintWorker('onFormat', cacheMaps.format_rules, lastResponse.format_rules);
        doResponse();
        yield lintWorker('onSyntax', cacheMaps.syntax_rules, lastResponse.syntax_rules);
        doResponse();
        yield worker('onSyntactic', cacheMaps.syntactic, lastResponse.syntactic);
        doResponse();
        yield worker('onSuggestion', cacheMaps.suggestion, lastResponse.suggestion);
        doResponse();
        yield lintWorker('onSemantic', cacheMaps.semantic_rules, lastResponse.semantic_rules);
        doResponse();
        yield worker('onSemantic', cacheMaps.semantic, lastResponse.semantic);
        doResponse();
        yield worker('onDeclaration', cacheMaps.declaration, lastResponse.declaration);
        return collectErrors();
        function doResponse() {
            if (errorsUpdated && !updateCacheRangeFailed) {
                response === null || response === void 0 ? void 0 : response(collectErrors());
                errorsUpdated = false;
            }
        }
        function collectErrors() {
            return Object.values(lastResponse).flatMap(({ errors }) => errors);
        }
        function lintWorker(api, cacheMap, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield (0, featureWorkers_1.ruleWorker)(context, api, uri, file => api === 'onFormat' ? !!file.capabilities.documentFormatting : !!file.capabilities.diagnostic, (ruleName, rule, ruleCtx) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e, _f, _g;
                    var _h, _j, _k, _l;
                    if (token) {
                        if (Date.now() - lastCheckCancelAt >= 5) {
                            yield shared.sleep(5); // wait for LSP event polling
                            lastCheckCancelAt = Date.now();
                        }
                        if (token.isCancellationRequested) {
                            return;
                        }
                    }
                    const pluginCache = (_a = cacheMap.get(ruleName)) !== null && _a !== void 0 ? _a : cacheMap.set(ruleName, new Map()).get(ruleName);
                    const cache = pluginCache.get(ruleCtx.document.uri);
                    const tsProjectVersion = (api === 'onSemantic') ? (_c = (_b = context.core.typescript.languageServiceHost).getProjectVersion) === null || _c === void 0 ? void 0 : _c.call(_b) : undefined;
                    if (api === 'onSemantic') {
                        if (cache && cache.documentVersion === ruleCtx.document.version && cache.tsProjectVersion === tsProjectVersion) {
                            return cache.errors;
                        }
                    }
                    else {
                        if (cache && cache.documentVersion === ruleCtx.document.version) {
                            return cache.errors;
                        }
                    }
                    const reportResults = [];
                    ruleCtx.report = (error, ...fixes) => {
                        var _a, _b;
                        if (!vscode.Diagnostic.is(error)) {
                            console.warn('[volar/rules-api] report() error must be a Diagnostic.');
                            return;
                        }
                        error.message || (error.message = 'No message.');
                        error.source || (error.source = 'rules');
                        error.code || (error.code = ruleCtx.ruleId);
                        const severity = (_b = (_a = context.config.lint) === null || _a === void 0 ? void 0 : _a.severities) === null || _b === void 0 ? void 0 : _b[ruleCtx.ruleId];
                        if (severity !== undefined) {
                            error.severity = severity;
                        }
                        reportResults.push([error, ...fixes]);
                    };
                    try {
                        yield ((_d = rule[api]) === null || _d === void 0 ? void 0 : _d.call(rule, ruleCtx));
                    }
                    catch (err) {
                        console.warn(`[volar/rules-api] ${ruleName} ${api} error.`);
                        console.warn(err);
                    }
                    (_e = context.ruleFixes) !== null && _e !== void 0 ? _e : (context.ruleFixes = {});
                    (_f = (_h = context.ruleFixes)[_j = ruleCtx.document.uri]) !== null && _f !== void 0 ? _f : (_h[_j] = {});
                    (_g = (_k = context.ruleFixes[ruleCtx.document.uri])[_l = ruleCtx.ruleId]) !== null && _g !== void 0 ? _g : (_k[_l] = {});
                    reportResults === null || reportResults === void 0 ? void 0 : reportResults.forEach(([error, ...fixes], index) => {
                        context.ruleFixes[ruleCtx.document.uri][ruleCtx.ruleId][index] = [error, fixes];
                        error.data = {
                            uri,
                            version: newDocument.version,
                            type: 'rule',
                            isFormat: api === 'onFormat',
                            pluginOrRuleId: ruleCtx.ruleId,
                            original: {
                                data: error.data,
                            },
                            ruleFixIndex: index,
                            documentUri: ruleCtx.document.uri,
                        };
                    });
                    errorsUpdated = true;
                    const errors = reportResults.map(reportResult => reportResult[0]);
                    pluginCache.set(ruleCtx.document.uri, {
                        documentVersion: ruleCtx.document.version,
                        errors,
                        tsProjectVersion,
                    });
                    return errors;
                }), api === 'onFormat' ? transformFormatErrorRange : transformErrorRange, arr => arr.flat());
                if (result) {
                    cache.errors = result;
                    cache.snapshot = newSnapshot;
                }
            });
        }
        function worker(api, cacheMap, cache) {
            return __awaiter(this, void 0, void 0, function* () {
                const result = yield (0, featureWorkers_1.languageFeatureWorker)(context, uri, true, function* (arg, _, file) {
                    if (file.capabilities.diagnostic) {
                        yield arg;
                    }
                }, (plugin, document) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e;
                    if (token) {
                        if (Date.now() - lastCheckCancelAt >= 5) {
                            yield shared.sleep(5); // wait for LSP event polling
                            lastCheckCancelAt = Date.now();
                        }
                        if (token.isCancellationRequested) {
                            return;
                        }
                    }
                    const pluginId = Object.keys(context.plugins).find(key => context.plugins[key] === plugin);
                    const pluginCache = (_a = cacheMap.get(pluginId)) !== null && _a !== void 0 ? _a : cacheMap.set(pluginId, new Map()).get(pluginId);
                    const cache = pluginCache.get(document.uri);
                    const tsProjectVersion = (api === 'onDeclaration' || api === 'onSemantic') ? (_c = (_b = context.core.typescript.languageServiceHost).getProjectVersion) === null || _c === void 0 ? void 0 : _c.call(_b) : undefined;
                    if (api === 'onDeclaration' || api === 'onSemantic') {
                        if (cache && cache.documentVersion === document.version && cache.tsProjectVersion === tsProjectVersion) {
                            return cache.errors;
                        }
                    }
                    else {
                        if (cache && cache.documentVersion === document.version) {
                            return cache.errors;
                        }
                    }
                    const errors = yield ((_e = (_d = plugin.validation) === null || _d === void 0 ? void 0 : _d[api]) === null || _e === void 0 ? void 0 : _e.call(_d, document));
                    errors === null || errors === void 0 ? void 0 : errors.forEach(error => {
                        error.data = {
                            uri,
                            version: newDocument.version,
                            type: 'plugin',
                            pluginOrRuleId: pluginId,
                            isFormat: false,
                            original: {
                                data: error.data,
                            },
                            ruleFixIndex: 0,
                            documentUri: document.uri,
                        };
                    });
                    errorsUpdated = true;
                    pluginCache.set(document.uri, {
                        documentVersion: document.version,
                        errors,
                        tsProjectVersion,
                    });
                    return errors;
                }), transformErrorRange, arr => dedupe.withDiagnostics(arr.flat()));
                if (result) {
                    cache.errors = result;
                    cache.snapshot = newSnapshot;
                }
            });
        }
    });
    function transformFormatErrorRange(errors, map) {
        const result = [];
        for (const error of errors) {
            // clone it to avoid modify cache
            let _error = Object.assign({}, error);
            if (map) {
                const range = map.toSourceRange(error.range);
                if (!range) {
                    continue;
                }
                _error.range = range;
            }
            result.push(_error);
        }
        return result;
    }
    function transformErrorRange(errors, map) {
        const result = [];
        for (const error of errors) {
            // clone it to avoid modify cache
            let _error = Object.assign({}, error);
            if (map) {
                const range = map.toSourceRange(error.range, data => !!data.diagnostic);
                if (!range) {
                    continue;
                }
                _error.range = range;
            }
            if (_error.relatedInformation) {
                const relatedInfos = [];
                for (const info of _error.relatedInformation) {
                    if (context.documents.hasVirtualFileByUri(info.location.uri)) {
                        for (const [_, map] of context.documents.getMapsByVirtualFileUri(info.location.uri)) {
                            const range = map.toSourceRange(info.location.range, data => !!data.diagnostic);
                            if (range) {
                                relatedInfos.push({
                                    location: {
                                        uri: map.sourceFileDocument.uri,
                                        range,
                                    },
                                    message: info.message,
                                });
                            }
                        }
                    }
                    else {
                        relatedInfos.push(info);
                    }
                }
                _error.relatedInformation = relatedInfos;
            }
            result.push(_error);
        }
        return result;
    }
}
exports.register = register;
//# sourceMappingURL=validation.js.map