var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
const html = __importStar(require("vscode-html-languageservice"));
const vscode = __importStar(require("vscode-languageserver-protocol"));
const path = __importStar(require("path"));
function isEOL(content, offset) {
    return isNewlineCharacter(content.charCodeAt(offset));
}
const CR = '\r'.charCodeAt(0);
const NL = '\n'.charCodeAt(0);
function isNewlineCharacter(charCode) {
    return charCode === CR || charCode === NL;
}
module.exports = (options = {}) => (context) => {
    let inited = false;
    let customData = [];
    let extraData = [];
    const htmlLs = html.getLanguageService({ fileSystemProvider: context.env.fileSystemProvider });
    const htmlDocuments = new WeakMap();
    return {
        rules: {
            onAny(context) {
                return __awaiter(this, void 0, void 0, function* () {
                    if (options.validLang === 'html') {
                        yield worker(context.document, (htmlDocument) => {
                            context.html = {
                                document: htmlDocument,
                                languageService: htmlLs,
                            };
                        });
                    }
                    return context;
                });
            },
        },
        getHtmlLs: () => htmlLs,
        updateCustomData,
        complete: {
            // https://github.com/microsoft/vscode/blob/09850876e652688fb142e2e19fd00fd38c0bc4ba/extensions/html-language-features/server/src/htmlServer.ts#L183
            triggerCharacters: ['.', ':', '<', '"', '=', '/'],
            on(document, position) {
                return __awaiter(this, void 0, void 0, function* () {
                    return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                        var _a;
                        const configs = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.completion'));
                        if (context.env.documentContext) {
                            return htmlLs.doComplete2(document, position, htmlDocument, context.env.documentContext, configs);
                        }
                        else {
                            return htmlLs.doComplete(document, position, htmlDocument, configs);
                        }
                    }));
                });
            },
        },
        rename: {
            prepare(document, position) {
                return worker(document, (htmlDocument) => {
                    var _a, _b;
                    const offset = document.offsetAt(position);
                    return (_b = (_a = htmlLs
                        .findDocumentHighlights(document, position, htmlDocument)) === null || _a === void 0 ? void 0 : _a.find(h => offset >= document.offsetAt(h.range.start) && offset <= document.offsetAt(h.range.end))) === null || _b === void 0 ? void 0 : _b.range;
                });
            },
            on(document, position, newName) {
                return worker(document, (htmlDocument) => {
                    return htmlLs.doRename(document, position, newName, htmlDocument);
                });
            },
        },
        doHover(document, position) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const hoverSettings = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.hover'));
                    return htmlLs.doHover(document, position, htmlDocument, hoverSettings);
                }));
            });
        },
        findDocumentHighlights(document, position) {
            return worker(document, (htmlDocument) => {
                return htmlLs.findDocumentHighlights(document, position, htmlDocument);
            });
        },
        findDocumentLinks(document) {
            return worker(document, () => {
                if (!context.env.documentContext)
                    return;
                return htmlLs.findDocumentLinks(document, context.env.documentContext);
            });
        },
        findDocumentSymbols(document) {
            return worker(document, (htmlDocument) => {
                return htmlLs.findDocumentSymbols(document, htmlDocument);
            });
        },
        getFoldingRanges(document) {
            return worker(document, () => {
                return htmlLs.getFoldingRanges(document);
            });
        },
        getSelectionRanges(document, positions) {
            return worker(document, () => {
                return htmlLs.getSelectionRanges(document, positions);
            });
        },
        format(document, formatRange, options) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, () => __awaiter(this, void 0, void 0, function* () {
                    var _a;
                    const options_2 = yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.format'));
                    if ((options_2 === null || options_2 === void 0 ? void 0 : options_2.enable) === false) {
                        return;
                    }
                    { // https://github.com/microsoft/vscode/blob/dce493cb6e36346ef2714e82c42ce14fc461b15c/extensions/html-language-features/server/src/modes/formatting.ts#L13-L23
                        const endPos = formatRange.end;
                        let endOffset = document.offsetAt(endPos);
                        const content = document.getText();
                        if (endPos.character === 0 && endPos.line > 0 && endOffset !== content.length) {
                            // if selection ends after a new line, exclude that new line
                            const prevLineStart = document.offsetAt(vscode.Position.create(endPos.line - 1, 0));
                            while (isEOL(content, endOffset - 1) && endOffset > prevLineStart) {
                                endOffset--;
                            }
                            formatRange = vscode.Range.create(formatRange.start, document.positionAt(endOffset));
                        }
                    }
                    return htmlLs.format(document, formatRange, Object.assign(Object.assign({}, options_2), options));
                }));
            });
        },
        getIndentSensitiveLines(document) {
            return worker(document, () => {
                const lines = [];
                const scanner = htmlLs.createScanner(document.getText());
                let token = scanner.scan();
                let startCommentTagLine;
                while (token !== html.TokenType.EOS) {
                    if (token === html.TokenType.StartCommentTag) {
                        startCommentTagLine = document.positionAt(scanner.getTokenOffset()).line;
                    }
                    else if (token === html.TokenType.EndCommentTag) {
                        const line = document.positionAt(scanner.getTokenOffset()).line;
                        for (let i = startCommentTagLine + 1; i <= line; i++) {
                            lines.push(i);
                        }
                    }
                    token = scanner.scan();
                }
                return lines;
            });
        },
        findLinkedEditingRanges(document, position) {
            return worker(document, (htmlDocument) => {
                const ranges = htmlLs.findLinkedEditingRanges(document, position, htmlDocument);
                if (!ranges)
                    return;
                return { ranges };
            });
        },
        doAutoInsert(document, position, insertContext) {
            return __awaiter(this, void 0, void 0, function* () {
                return worker(document, (htmlDocument) => __awaiter(this, void 0, void 0, function* () {
                    var _a, _b, _c, _d, _e;
                    const lastCharacter = insertContext.lastChange.text[insertContext.lastChange.text.length - 1];
                    if (insertContext.lastChange.rangeLength === 0 && lastCharacter === '=') {
                        const enabled = (_b = (yield ((_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.getConfiguration('html.autoCreateQuotes')))) !== null && _b !== void 0 ? _b : true;
                        if (enabled) {
                            const text = htmlLs.doQuoteComplete(document, position, htmlDocument, yield ((_c = context.env.configurationHost) === null || _c === void 0 ? void 0 : _c.getConfiguration('html.completion')));
                            if (text) {
                                return text;
                            }
                        }
                    }
                    if (insertContext.lastChange.rangeLength === 0 && (lastCharacter === '>' || lastCharacter === '/')) {
                        const enabled = (_e = (yield ((_d = context.env.configurationHost) === null || _d === void 0 ? void 0 : _d.getConfiguration('html.autoClosingTags')))) !== null && _e !== void 0 ? _e : true;
                        if (enabled) {
                            const text = htmlLs.doTagComplete(document, position, htmlDocument);
                            if (text) {
                                return text;
                            }
                        }
                    }
                }));
            });
        },
    };
    function initCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (!inited && !options.disableCustomData) {
                inited = true;
                (_a = context.env.configurationHost) === null || _a === void 0 ? void 0 : _a.onDidChangeConfiguration(() => __awaiter(this, void 0, void 0, function* () {
                    customData = yield getCustomData();
                    htmlLs.setDataProviders(true, [...customData, ...extraData]);
                }));
                customData = yield getCustomData();
                htmlLs.setDataProviders(true, [...customData, ...extraData]);
            }
        });
    }
    function updateCustomData(data) {
        extraData = data;
        htmlLs.setDataProviders(true, [...customData, ...extraData]);
    }
    function getCustomData() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const configHost = context.env.configurationHost;
            if (configHost) {
                const customData = (_a = yield configHost.getConfiguration('html.customData')) !== null && _a !== void 0 ? _a : [];
                const newData = [];
                for (const customDataPath of customData) {
                    try {
                        const jsonPath = path.resolve(customDataPath);
                        newData.push(html.newHTMLDataProvider(customDataPath, require(jsonPath)));
                    }
                    catch (error) {
                        console.error(error);
                    }
                }
                return newData;
            }
            return [];
        });
    }
    function worker(document, callback) {
        return __awaiter(this, void 0, void 0, function* () {
            const htmlDocument = getHtmlDocument(document);
            if (!htmlDocument)
                return;
            yield initCustomData();
            return callback(htmlDocument);
        });
    }
    function getHtmlDocument(document) {
        var _a;
        if (document.languageId !== ((_a = options.validLang) !== null && _a !== void 0 ? _a : 'html'))
            return;
        const cache = htmlDocuments.get(document);
        if (cache) {
            const [cacheVersion, cacheDoc] = cache;
            if (cacheVersion === document.version) {
                return cacheDoc;
            }
        }
        const doc = htmlLs.parseHTMLDocument(document);
        htmlDocuments.set(document, [document.version, doc]);
        return doc;
    }
};
//# sourceMappingURL=index.js.map